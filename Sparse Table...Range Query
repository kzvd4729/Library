/**************** Sparse for Range Min ***************/
int sp_min[N+2][21],SP[N+2];
void Sparse_Min_Build(int n)
{
  for(int i=1;i<=n;i++)
    sp_min[i][0]=SP[i];
  for(int j=1;j<=20;j++)
  {
    for(int i=1;i<=n;i++)
    {
      sp_min[i][j]=sp_min[i][j-1];
      if((i+(1<<(j-1)))>n)continue;
      sp_min[i][j]=min(sp_min[i][j-1],sp_min[i+(1<<(j-1))][j-1]);
    }
  }
}
int Query_Min(int lt,int rt)
{
  //if(rt<lt)return 1e9;
  int dg=31-__builtin_clz(rt-lt+1);
  return min(sp_min[lt][dg],sp_min[rt-(1<<dg)+1][dg]);
}
/////////////////////////////////////////////////////////


/********************** 2D RMQ********************/
for(long i=1;i<=n;i++)
  {
    deque<pair<long,long> >dq;
    for(long j=1;j<=m;j++)
    {
      while(dq.size())
      {
        if(dq.back().first>=mt[i][j])
          dq.pop_back();
        else break;
      }
      dq.push_back({mt[i][j],j});
      if(dq.front().second<=j-b)dq.pop_front();
      if(j-b+1>0)
      {
        tmp[i][j-b+1]=dq.front().first;
        //cout<<dq.front().first<<" ";
      }
    }
    //cout<<endl;
  }
  long ans=0;
  for(long j=1;j<=m-b+1;j++)
  {
    deque<pair<long,long> >dq;
    for(long i=1;i<=n;i++)
    {
      while(dq.size())
      {
        if(dq.back().first>=tmp[i][j])
          dq.pop_back();
        else break;
      }
      dq.push_back({tmp[i][j],i});
      if(dq.front().second<=i-a)dq.pop_front();
      if(i-a+1>0)ans+=dq.front().first;
    }
  }
  /***************************************************/
